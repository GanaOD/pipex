Quick notes, understanding the project:

Project goal: recreate shell's pipe behaviour
(not really "implementing" the pipe functionality from scratch, but learning how the shell itself uses these low-level system calls to implement its pipe operator (|) - essentially writing a mini-shell that handles one specific use case of piping)


When running shell command: < infile cmd1 | cmd2 > outfile
What's happening here:
The shell redirects stdin from infile
Executes cmd1, which writes its output to a pipe
Executes cmd2, which reads its input from that pipe
Redirects cmd2's output to outfile



How to structure my implementation:

1. Create a pipe using pipe(int fd[2]):

fd[0] is the read end
fd[1] is the write end


2. Fork to create a child process for cmd1:

a. Child:

Redirect stdin to infile using dup2()
Redirect stdout to pipe write end using dup2()
Execute cmd1 using execve()


b. Parent:

Fork again for cmd2




3. Fork to create a child process for cmd2:

a. Child:

Redirect stdin to pipe read end using dup2()
Redirect stdout to outfile using dup2()
Execute cmd2 using execve()


b. Parent:

Wait for both children to complete





Key system calls to use:

pipe(): Creates the communication channel
fork(): Creates new processes
dup2(): Redirects file descriptors
execve(): Executes commands
access(): Verifies command existence/permissions
waitpid(): Waits for child processes




Basic Program Flow:

1. Input validation
   - Check correct number of arguments
   - Validate input/output files
   - Parse commands

2. Pipeline setup
   - Create pipe
   - Fork processes
   - Setup file descriptors

3. Command execution
   - Find command paths
   - Execute commands with proper redirection
   - Handle errors

4. Cleanup
   - Close file descriptors
   - Free allocated memory
   - Wait for child processes



Pseudocode structure:

// pipex.h
typedef struct s_pipex {
    int		infile;
    int		outfile;
    int		pipe[2];
    char	*cmd1_path;
    char	*cmd2_path;
    char	**cmd1_args;
    char	**cmd2_args;
    char	**env;
} t_pipex;

// pipex.c
int main(int argc, char **argv, char **envp)
{
    t_pipex	pipex;

    // Validate arguments
    if (argc != 5)
        return (error_handler("Invalid number of arguments"));

    // Initialize pipex struct
    init_pipex(&pipex, argv, envp);

    // Execute pipeline
    execute_pipeline(&pipex);

    // Cleanup
    cleanup_pipex(&pipex);

    return (0);
}

void execute_pipeline(t_pipex *pipex)
{
    // Create pipe
    if (pipe(pipex->pipe) < 0)
        exit_error("Pipe creation failed");

    // First child process (cmd1)
    pid1 = fork();
    if (pid1 == 0)
        execute_cmd1(pipex);

    // Second child process (cmd2)
    pid2 = fork();
    if (pid2 == 0)
        execute_cmd2(pipex);

    // Parent process
    wait_children();
}
